Crea un plan detallado para comenzar a desarrollar un agente de IA que permita desarrollar codigo para SDK
  Comienza creando un archivo en md con algunos conceptos claves sobre el sistema EMIC, basado en @Manual_para_desarrolladores/Manual_Desarrollo_EMIC/Seccion_1_Introduccion\
  solo resume los conceptos relevantes para la creacion del agente:
  - Objetivo del agente.
  - Subagentes.
  - Orquestacion.
  - Estructura de la informacion.

  Contexto: el agente sera un CLI, creado con c# (tipo claude code)
  especifica la division de tareas y las etapas de ineraccion con el usuario.

  Los ejemplos de uso seran:
  "crear un nuevo modulos para sensar temperatura de entre -10 y 80 grados celcius"
  "crear una api para implentar un filtro IIR configurable"
  "crear un driver para el chip LM35"

  El agente debe asegurarse de quitar todas las ambiguedades del promp, haciendo las pregunatas necesarias hasta llegar a una definicion estricta
  Cuando se pide crear un modulo procurar reutilizar las apis y driver existente, si no existe una api adecuada crear una que sea independiente del modulos.
  Estrictamente prohibido modificar código de las apis y dreivers que estan siendo utilizadas por otros modulos, aunque si está permitido agregar nuevas fucniones .
  El sistema puede agregar en, cada carpeta, archivos con  metatexto e informacion para que los sub-agentes conozcan el estado del desarrollo, por ejemplo las distintas relaciones entre modulos, apis,
  driver, hal, hard, etc. O anotar si supero las pruebas de debugero, o cualquier referencia al avance del desarrollo.

  Importante: en el sistema emic existe un editor de codigo donde el usuario desarrolla un script codificado en un archivo llamado program.xml con la logica de la aplicacion que se agrega al proyecto de
  cada modulo, es por eso que habrá un subagente que se encargue de desarrollar el program.xml junto con otros archivos necesarios, Luego otro proceso que ya existe convierte el progam.xml en codigo C. y
  arma el proyecto completo con todas las librerias obtenidas del SDK,
  Tambien existirá un sub-agente que compile el codigo generado y obtenga la lista de errors de compilacion, esa lista se usara para corregir los error del codigo C de los archivos generados y de los
  archivos del SDK, (es decir retropropagrá las correcciones para generar una nueva version de codigo compilable , pero con los errores conocidos)
  La informacion sobre el flujo de trabajo de los proyectos para testeo sera provista cuando sea necesario implementar los sub-agentes asociados a la etapa de depuracion.

  Recomiendo usar distintos sub-agentes para verificar el cumplimiento de reglas no negocibles, como : Separacion en capas, Codigo no bloqueante, Maquinas de estados, etc.
  Comienza creando dentro de la carpeta de trabajo una carpeta como submodule git en donde se guardara el plan de trabajo, y todos los archivos relacionados mas el proyecto en C#.
  En esta etapa solo  crea las estructura del agente y subagentes.  y la interaccion entre los subagentes y el usuario. (puedes leer los archivos del SDK de ejemplo en esta carpeta.)



  vamos a repasar el flujo de trabajo con mas detalles:
  1. el usuario puede pedir un nuevo módulo, pcb , una api , un driver, o agregar alguna funcion de bajo nivel en  hard, con su respectivo hal. O puede pedir la adaptacion o conversión de un modulo , api o
  driver existente.
  2. El prompt puede tener ambiguedad, por lo tanto el agente debe obtener una definición clara y uníboca mediante preguntas y recomendaciones.
  3. El agente debe realizar un plan y division de tareas. entre distintos agentes, el diseño hay que pensarlo desde la capa superior a la inferior, luego se ejecutará de abajo hacia arriba.
  4. Solo creará la capa de hard/hal en caso que no exista el código necesario para cumplir con el requerimiento, es muy importante cuidar la retrocompatibilidad de todo el codigo existente , principalmente
  de las capas inferiores, si fuese necesario agregar funciones al codigo existente, debe hacerlo condicionando el nuevo codigo a la existencia de un parametro explicito, por ejemplo "useHhandshake=true" ,
  de tal manera que el codigo viejo ignore los nuevos features.
  5. Los drivers que cumplen las misma funciones debe tener funciones con nombres iguales, por ejemplo , todos los sensores de temperature tendran getTemperature se busca que sean intercambiables a nivel
  API. esto se implementa desde generate.emic cuando de invoca a la API le pasa como parametro el nombre del driver (ver en el modulo USB) :
  EMIC:setInput(DEV:_api/Wired_Communication/USB/USB_API.emic,driver=MCP2200,port=1,BufferSize=512,baud=9600,frameLf=\n)
  6. en general todas las opciones deben estar definida en el modulo y se propahan hacia abajo.
  7. Siempre que sea posible debe ralizarse todas las prueba y test físicos , en caso que el usuario solicite un driver o una api, el sistema debe planificar la mejor manera de realizar las pruebas, creando
  un modulo de test, que implente todas la funciones y eventos creados, ese modulo debería crearse en la categoria "test" o similar.
  8. Siempre que sea posible debe crease un proyecto de prueba donde se implementen todas las funciones del modulo , apis y drivers creados.
  9. Para obtener información respecto a como crear un proyecto emic. se puede consultar el ejemplo @INFO/DEV-APP/CLI/TUTORIAL_YOGURTERA_CONTROLLER.md tambien puedo indicarte la carpeta en donde se guardan
  mis proyectos (en el momento de ser requerido para la implentación de la fase  de depuracion)
  10. tener en cuenta que el codigo que se compila no es el codigo que se edita en el SDK, sino que es una expancion . realizada con un entorno definido por el usuario, por los tanto los errores de
  compilación no apuntan directamente al SDK, esto obliga a buscar una forma de inferir  que archivo del SDK genera se expande en el resultado expandido. Esto se puede hacer con un sistema de marcado del
  codigo generado en el momento de expandir cada archivo , y luego usar las marcas para retropropagar las correcciones, (este método puede ser mejorado , es por eso que debes agregar como tarea el diseño de
  la retropropagacion).
  NOTA 1: el reposiorio de la carpeta PIC_XC16 es un SDK de prueba en donde se pueden hacer cambios libremente (rompiendo algunas reglas que en produccion no se podran romper)
  NOTA 2: Alguns modulos , apis y drivers no estan funcionando, si encuentras algun modulo con muchas inconsistencias debes informarme para que yo lo borre.
  NOTA 3: queda pendiente la definción de un agente especializado en convertir versiones viejas a la version actual (anótalo)

   otras recomendaciones
  si  el usuario solo pide un sensor sin espscificar la salida, la desambiguacion deberia tener dos partes dundamentales:
  1- la especificacion del sensor.
  2- la especificacion de la salida que en este caso es mucho mas ambigua.
  para la 2 tener en cuenta que el modulo puede ser standalone o puede ser parte del sistema modular EMIC, (esta pregunta siempre debe ser aclarado , en caso que se un modulo del sistema EMIC se presupone
   que tiene la API de EMIC-bus (i2c) , pero no hace falta nombrarlo solo decir es un modulo del sistema modular  EMIC ). Esta pregunta se debe hacer cuando el la especificacion falta la salida o la
  entrada. porque se sospecha que la ambiguedad proviene de no aclarar que se trate de un modulo.
  Podria empezar el cuestionario diciendo : dime que  quieres crear   y dar opciones: proyecto monolitico ( de una sola placa) ,  modulo EMIC, sistema distribiido, etc.
  Entonses si es un modulo EMIC, puede preguntar: sensor, actuador , display, indicador, comunicacion, otro (especificar) , etc.
  si es un sistema unificado, deberia preguntar , si es un sistema de control cerrado , un sistema de monitoreo, control remoto, o combinacion de varios . siempre con una opcion para que el usuario pueda
  explicar si la opcion no esta en la lista.
  NOTA IMORTANTE: en esta etapa no hay que conocer los recursos existentes, eso vendra despues de obtener la especificacion. Lo veromos con detalle mas adelante.
