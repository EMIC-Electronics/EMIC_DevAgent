using EMIC.Shared.Services.Storage;
using EMIC_DevAgent.Core.Models.Generation;
using Microsoft.Extensions.Logging;

namespace EMIC_DevAgent.Core.Services.Compilation;

/// <summary>
/// Maps compilation errors in TARGET code back to SDK source files.
/// Uses .map TSV files generated by TreeMaker during EMIC:Generate
/// and falls back to filename matching.
/// </summary>
public class SourceMapper
{
    private readonly ILogger<SourceMapper> _logger;

    public SourceMapper(ILogger<SourceMapper> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Loads .map TSV files from SYS:map/TARGET/ for error resolution.
    /// These files are generated by TreeMaker.addToCodigo() during EMIC:Generate.
    /// </summary>
    /// <param name="mediaAccess">MediaAccess instance with virtual path resolution</param>
    /// <param name="systemPath">The SYS: base path (e.g., value from context.Properties["SystemPath"])</param>
    /// <returns>Dictionary with keys like "SYS:map/TARGET/xxx.c.map" and TSV content as values</returns>
    public Dictionary<string, string> LoadMapFiles(MediaAccess mediaAccess, string systemPath)
    {
        var result = new Dictionary<string, string>();

        var mapDir = $"{systemPath.TrimEnd('/')}/map/TARGET";

        try
        {
            if (!mediaAccess.Directory.Exists(mapDir))
            {
                _logger.LogDebug("Map directory does not exist: {MapDir}", mapDir);
                return result;
            }

            var mapFiles = mediaAccess.Directory.GetFiles(mapDir, "*.map");
            if (mapFiles.Length == 0)
            {
                _logger.LogDebug("No .map files found in {MapDir}", mapDir);
                return result;
            }

            foreach (var mapFile in mapFiles)
            {
                try
                {
                    var content = mediaAccess.File.ReadAllText(mapFile);
                    // Normalize key to SYS:map/TARGET/filename.map format
                    var fileName = mapFile.Split(new[] { '/' }, StringSplitOptions.RemoveEmptyEntries).Last();
                    var key = $"SYS:map/TARGET/{fileName}";
                    result[key] = content;
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Failed to read map file: {MapFile}", mapFile);
                }
            }

            _logger.LogInformation("Loaded {Count} .map files from {MapDir}", result.Count, mapDir);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error loading map files from {MapDir}", mapDir);
        }

        return result;
    }

    /// <summary>
    /// Maps a CompilationError to the original generated file.
    /// Strategy 1: Use .map TSV files for exact line-level resolution.
    /// Strategy 2: Fallback to filename matching.
    /// </summary>
    public SourceMappedError? MapError(CompilationError error, List<GeneratedFile> generatedFiles,
        Dictionary<string, string>? mapFiles = null)
    {
        // Strategy 1: Use .map TSV files for exact resolution
        if (mapFiles != null && mapFiles.Count > 0 && !string.IsNullOrEmpty(error.FilePath) && error.Line > 0)
        {
            var resolved = ResolveSourceLocation(error.FilePath, error.Line, mapFiles);
            if (resolved.HasValue)
            {
                var (sourceFile, sourceLine, comment) = resolved.Value;

                // Find the GeneratedFile that matches the resolved source file
                var matchedFile = generatedFiles.FirstOrDefault(f =>
                    f.RelativePath.Equals(sourceFile, StringComparison.OrdinalIgnoreCase) ||
                    sourceFile.EndsWith(f.RelativePath, StringComparison.OrdinalIgnoreCase) ||
                    f.RelativePath.EndsWith(sourceFile, StringComparison.OrdinalIgnoreCase) ||
                    Path.GetFileName(f.RelativePath).Equals(Path.GetFileName(sourceFile), StringComparison.OrdinalIgnoreCase));

                if (matchedFile != null)
                {
                    _logger.LogDebug("Mapped error via .map TSV: {TargetFile}:{TargetLine} -> {SourceFile}:{SourceLine}",
                        error.FilePath, error.Line, matchedFile.RelativePath, sourceLine);

                    return new SourceMappedError
                    {
                        OriginalError = error,
                        MappedFile = matchedFile,
                        MappedLine = sourceLine
                    };
                }
                else
                {
                    _logger.LogDebug("Resolved source {SourceFile}:{SourceLine} but no matching GeneratedFile found",
                        sourceFile, sourceLine);
                }
            }
        }

        // Strategy 2: Fallback to filename matching
        var errorFileName = Path.GetFileName(error.FilePath);
        if (!string.IsNullOrEmpty(errorFileName))
        {
            var fileByName = generatedFiles.FirstOrDefault(f =>
                (f.Type == FileType.Source || f.Type == FileType.Header) &&
                Path.GetFileName(f.RelativePath).Equals(errorFileName, StringComparison.OrdinalIgnoreCase));

            if (fileByName != null)
            {
                _logger.LogDebug("Mapped error by filename: {ErrorFile} -> {File}:{Line}",
                    error.FilePath, fileByName.RelativePath, error.Line);

                return new SourceMappedError
                {
                    OriginalError = error,
                    MappedFile = fileByName,
                    MappedLine = error.Line
                };
            }
        }

        _logger.LogDebug("Could not map error in {File}:{Line}", error.FilePath, error.Line);
        return null;
    }

    /// <summary>
    /// Resolves a TARGET file + line to the original source file + line using .map TSV data.
    /// Equivalent to CompilerService.ResolveSourceLocation() but without the [Obsolete] dependency.
    /// </summary>
    private static (string sourceFile, int sourceLine, string comment)? ResolveSourceLocation(
        string targetFile, int targetLine, Dictionary<string, string> mapFiles)
    {
        if (string.IsNullOrEmpty(targetFile) || targetLine < 1 || mapFiles == null || mapFiles.Count == 0)
            return null;

        try
        {
            string fileName = targetFile.Split(new[] { '/', '\\' }, StringSplitOptions.RemoveEmptyEntries).Last();

            string? mapKey = mapFiles.Keys.FirstOrDefault(k =>
                k.EndsWith($"/{fileName}.map", StringComparison.OrdinalIgnoreCase));

            if (mapKey == null)
                return null;

            string mapContent = mapFiles[mapKey];
            var lines = mapContent.Split('\n');

            // .map is 0-indexed, compiler reports 1-indexed
            int mapIndex = targetLine - 1;
            if (mapIndex < 0 || mapIndex >= lines.Length)
                return null;

            string mapLine = lines[mapIndex];
            var parts = mapLine.Split('\t');

            if (parts.Length < 2)
                return null;

            if (!int.TryParse(parts[0].Trim(), out int originLine))
                return null;

            string originFile = parts[1].Trim();
            string comment = parts.Length > 2 ? parts[2].Trim() : "";

            // originLine in .map is 0-indexed, convert to 1-indexed
            return (originFile, originLine + 1, comment);
        }
        catch
        {
            return null;
        }
    }
}

public class SourceMapping
{
    public string OriginalFilePath { get; set; } = string.Empty;
    public int OriginalLine { get; set; }
    public int ExpandedLine { get; set; }
}

public class SourceMappedError
{
    public CompilationError OriginalError { get; set; } = null!;
    public GeneratedFile MappedFile { get; set; } = null!;
    public int MappedLine { get; set; }
}
